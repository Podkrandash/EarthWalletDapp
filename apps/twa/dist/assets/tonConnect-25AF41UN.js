var x=Object.defineProperty;var A=(t,e,n)=>e in t?x(t,e,{enumerable:!0,configurable:!0,writable:!0,value:n}):t[e]=n;var d=(t,e,n)=>(A(t,typeof e!="symbol"?e+"":e,n),n);import{eU as y,b9 as b,c as f,eV as L,y as w,Q as p,eW as I,bE as E,aD as P,a_ as $,aO as B,a$ as _,eX as D,eY as M,eZ as W}from"./index-DR6GvvU1.js";function N(t,e){const n=new Uint8Array(t.length+e.length);return n.set(t),n.set(e,t.length),n}function O(t){let e="";return t.forEach(n=>{e+=("0"+(n&255).toString(16)).slice(-2)}),e}class g{constructor(e){d(this,"nonceLength",24);d(this,"keyPair");d(this,"sessionId");this.keyPair=e?this.createKeypairFromString(e):this.createKeypair(),this.sessionId=O(this.keyPair.publicKey)}createKeypair(){return y.box.keyPair()}createKeypairFromString(e){return{publicKey:Buffer.from(e.publicKey,"hex"),secretKey:Buffer.from(e.secretKey,"hex")}}createNonce(){return y.randomBytes(this.nonceLength)}encrypt(e,n){const s=new TextEncoder().encode(e),r=this.createNonce(),o=y.box(s,r,n,this.keyPair.secretKey);return N(r,o)}decrypt(e,n){const s=e.subarray(0,this.nonceLength),r=e.subarray(this.nonceLength);console.log("senderPublicKey",n.length);const o=y.box.open(r,s,n,this.keyPair.secretKey);if(!o)throw new Error(`Decryption error: 
 message: ${e.toString()} 
 sender pubkey: ${n.toString()} 
 keypair pubkey: ${this.keyPair.publicKey.toString()} 
 keypair secretkey: ${this.keyPair.secretKey.toString()}`);return new TextDecoder().decode(o)}stringifyKeypair(){return{publicKey:Buffer.from(this.keyPair.publicKey).toString("hex"),secretKey:Buffer.from(this.keyPair.secretKey).toString("hex")}}}const C="https://bridge.tonapi.io/bridge",Q=300,R=async({response:t,sessionKeyPair:e,clientSessionId:n,ttl:s=Q,bridgeUrl:r=C})=>{const o=new g(e),a=`${r}/message?client_id=${o.sessionId}&to=${n}&ttl=${s}`,c=o.encrypt(JSON.stringify(t),Buffer.from(n,"hex"));await fetch(a,{body:Buffer.from(c).toString("base64"),method:"POST"})},U=async t=>await t.get(b.LAST_HTTP_EVENT_ID)??void 0,V=async(t,e)=>{await t.set(b.LAST_HTTP_EVENT_ID,e)},X=({storage:t,handleMessage:e,connections:n,lastEventId:s,bridgeUrl:r=C,EventSourceClass:o=EventSource})=>{if(!n||n.length===0)return()=>{};const a=n.map(l=>new g(l.sessionKeyPair).sessionId).join(",");let c=`${r}/events?client_id=${a}`;s&&(c+=`&last_event_id=${s}`),console.log("sse connect",c);const i=new o(c),u=l=>{console.log("sse message received",l.data),V(t,l.lastEventId);const{from:m,message:K}=JSON.parse(l.data),v=n.find(k=>k.clientSessionId===m);v&&(console.log("sse message processed",l.data),e(F({message:K,from:m,connection:v})))},h=()=>{console.log("sse connect: opened")},S=l=>{console.log("sse connect: error",l)};return i.addEventListener("message",u),i.addEventListener("open",h),i.addEventListener("error",S),()=>{i.removeEventListener("message",u),i.removeEventListener("open",h),i.removeEventListener("error",S),i.close()}},F=({message:t,from:e,connection:n})=>{const s=new g(n.sessionKeyPair);return{request:JSON.parse(s.decrypt(Buffer.from(t,"base64"),Buffer.from(e,"hex"))),connection:n}},H=()=>{const t=f(),{data:e}=L(),n=e==null?void 0:e.flatMap(s=>s.allTonWallets);return w([p.tonConnectConnection,n==null?void 0:n.map(s=>s.id)],async()=>D(t.storage),{enabled:n!==void 0})},Y=()=>{const t=f();return w([p.tonConnectLastEventId],async()=>U(t.storage))},Z=()=>{const t=f(),e=E(),{data:n,...s}=H();if(!n)return{data:void 0,...s};if(t.targetEnv==="extension"){const o=n.flatMap(c=>c.connections),a=[];return o.forEach(c=>{a.every(i=>i.webViewUrl!==c.webViewUrl)&&a.push(c)}),{data:a,...s}}const r=n.find(o=>o.wallet.id===e.id);return r?{data:r.connections,...s}:{data:void 0,...s}},J=I(),z=t=>{const e=f(),n=E(),s=P(),r=$().filter(B);return _(async o=>{let a;e.targetEnv!=="extension"?a=await T(e.storage,o,n):a=(await Promise.all(r.flatMap(c=>c.allTonWallets).map(c=>T(e.storage,o,c)))).flat(),t!=null&&t.skipEmit||J.next(a),e.notifications&&await Promise.all(a.map(c=>{var i;return(i=e.notifications)==null?void 0:i.unsubscribeTonConnect(c.clientSessionId).catch(u=>console.warn(u))})),await s.invalidateQueries([p.tonConnectConnection])})},T=async(t,e,n)=>{let s=await M(t,n);const r=e==="all"?s:[e];return s=e==="all"?[]:s.filter(o=>r.every(a=>a.clientSessionId!==o.clientSessionId)),await W(t,n,s),r};export{z as a,H as b,Y as c,X as d,R as s,J as t,Z as u};
